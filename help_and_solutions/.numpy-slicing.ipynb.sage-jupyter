{"kernelspec":{"display_name":"Python 2 (SageMath)","language":"python","name":"python2"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"code","execution_count":12,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/html":"smc-blob::6bb1a1ec-6a3a-4f4b-908f-4f8ae9bef8ee","text/plain":"<IPython.core.display.HTML object>"},"execution_count":12,"metadata":{},"output_type":"execute_result"}],"source":"from IPython.core.display import HTML\ncss_file = '../styles/styles.css'\nHTML(open(css_file, \"r\").read())"}
{"cell_type":"markdown","metadata":{"collapsed":false},"source":"# An idiots guide to NumPy arrays and slicing\n\nFollowing the first two homeworks, it seems that what most people are struggling with is how to select sections of NumPy arrays. Heres a quick guide to help. We'll start with 1D arrays and move up to 2D arrays.\n\n----\n\n## Remember - NumPy is great for avoiding ```for``` loops\n\nAlmost the entire point of NumPy is that you can perform operations on the whole array at once, without for loops. For example, if we want to make an array of x values between $0$ and $2\\pi$, and calculate the sine of all those values at once..."}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"import numpy as np\nimport matplotlib.pyplot as plt\n%matplotlib inline"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"[<matplotlib.lines.Line2D at 0x7fd19dc91f90>]"},"execution_count":2,"metadata":{},"output_type":"execute_result"},{"data":{"image/png":"smc-blob::4ab57c62-5776-405f-9cd3-1f86f083a75a","text/plain":"<matplotlib.figure.Figure at 0x7fd19e61f650>"},"metadata":{},"output_type":"display_data"}],"source":"x = np.linspace(0.0, 2.0*np.pi, 500)  # 500 values linearly spaced between 0 and 2pi\ny = np.sin(x) # sine of all values in one line - no for loop!\nplt.plot(x,y)"}
{"cell_type":"markdown","metadata":{},"source":"## 1D arrays and slicing\n\nTo illustrate *slicing*, which is just getting a subsection of an array, I'm going to make an array with the numbers 1-20 in it"}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[ 1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20]\n"}],"source":"x = np.arange(1,21,1)\nprint(x) # notice how I check I've got it right by printing x?"}
{"cell_type":"markdown","metadata":{},"source":"Slices of arrays are made using the square bracket notation. Within the brackets we indicate which slice we want. For example, I select a basic slice by indicating the *start index* and the *stop index*, seperated by a colon. So the following gives me the elements 0,1,2,3:"}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[1 2 3 4]\n"}],"source":"print(x[0:4])"}
{"cell_type":"markdown","metadata":{},"source":"### Leaving out values\n\nI don't need to put both the start and the stop value in the slice. If I miss out the start, it will begin the slice at 0. If I miss out the end, the slice will run to the end of the array."}
{"cell_type":"code","execution_count":6,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[ 1  2  3  4  5  6  7  8  9 10]\n"}],"source":"print(x[:10])"}
{"cell_type":"code","execution_count":7,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[11 12 13 14 15 16 17 18 19 20]\n"}],"source":"print(x[10:])"}
{"cell_type":"markdown","metadata":{},"source":"### Fancy Slicing\n\nThe real special sauce is using numpy arrays themselves to specify the slice. If I supply an array (known as a **mask**) for the slice, whose values are either ```True``` or ```False```, I will get in return only those elements of the original array where the mask was ```True```. Follow along below:"}
{"cell_type":"code","execution_count":8,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[False False False False False False False False False False False False\n False  True  True  True  True  True  True  True]\n"}],"source":"print(x > 13) ## notice how comparing x to 13 compares every valuein the array and gives me an array of true/false values"}
{"cell_type":"code","execution_count":9,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[14 15 16 17 18 19 20]\n"}],"source":"mask = (x > 13) # save the mask in the variable called mask\nprint(x[mask]) # use the numpy array as a mask, selecting only elements where the mask is True"}
{"cell_type":"markdown","metadata":{},"source":"This will work with **any** array of True/False values, as long as it's the right length.\n\n## Slices of arrays are themselves arrays\n\nNote that when I slice an array, I get an array:"}
{"cell_type":"code","execution_count":10,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[14 15 16 17 18 19 20]\n<type 'numpy.ndarray'>\n"}],"source":"selection = x[mask]\nprint(selection)\nprint(type(selection))"}
{"cell_type":"markdown","metadata":{},"source":"---\n\n## 2D arrays.\n\n2D arrays are in many ways no different to 1D arrays, except that we can specify a slice for both rows and columns. Let's read in the data from the first numpy notebook "}
{"cell_type":"code","execution_count":14,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"(77431, 7)\n"}],"source":"data = np.loadtxt('../data/Session1/td_stockholm.dat',skiprows=1)\nprint(data.shape)"}
{"cell_type":"markdown","metadata":{},"source":"This is a 2D array. With 77431 rows and 7 columns. The notation for slicing from a 2D array is ```array[row_slice, column_slice]```. Any valid slice you could use for the 1D arrays, you can use to slice either rows or columns. So, the below selects all the rows, and column 5 (temperature) only:"}
{"cell_type":"code","execution_count":15,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"5.78546189511\n"}],"source":"temperature = data[0:77431, 5] # row slice is all rows, column slice is a single column\nprint(temperature.mean())"}
{"cell_type":"markdown","metadata":{},"source":"Slices work exactly as they did for 1D arrays, so the code below does the same as above:"}
{"cell_type":"code","execution_count":16,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"temperature = data[:, 5] # row slice selects all rows, column slice is single column"}
{"cell_type":"markdown","metadata":{},"source":"I don't have to choose all the rows. I can just choose the first four rows..."}
{"cell_type":"code","execution_count":17,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"[ -6.1 -15.4 -15.  -19.3]\n"}],"source":"print(data[:4, 5]) # row slice is 0:4 (don't have to write the 0), column slice is single column"}
{"cell_type":"markdown","metadata":{},"source":"I can also use **fancy slices** to select values from either rows or columns or both. The only constraint is that my **mask** of true and false values must have the correct number of elements within it. So, I could select the temperature column, and create a mask which is true when the temperature is >0 by:"}
{"cell_type":"code","execution_count":18,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"(77431, 77431)\n"}],"source":"temperature = data[:, 5]\nnot_freezing_mask = (temperature > 0) ## RHS checks every element in temperature array and returns true or false\n\nprint(temperature.size, not_freezing_mask.size) ## one entry in not_freezing_mask for every row"}
{"cell_type":"markdown","metadata":{},"source":"And now, I can use that mask to select the rows where the temperature is >0. I just use the mask for the row slice, so I select all the rows where the mask is ```True```. I can put anything I like in the column slice - I can select all the columns, or only the columns I care about"}
{"cell_type":"code","execution_count":20,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"(57438, 7)\n(77431, 7)\n"}],"source":"all_data_not_freezing = data[not_freezing_mask, :] # use the mask for the row slice , select all the columns\nprint(all_data_not_freezing.shape)\nprint(data.shape)"}
{"cell_type":"markdown","metadata":{},"source":"Column 1 is the month, so if I want a 1D array of all the months where the temperature is >0:"}
{"cell_type":"code","execution_count":23,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::51d17c30-d588-4157-8766-76247639f129","text/plain":"<matplotlib.figure.Figure at 0x7fd19818c0d0>"},"metadata":{},"output_type":"display_data"}],"source":"warm_months = data[not_freezing_mask, 1] # row slice uses mask - only those rows where temp > 0, column slice selects column 1 (month)\nplt.hist(warm_months);"}
{"cell_type":"markdown","metadata":{},"source":"As you can see, not so warm in Jan and Feb."}
{"cell_type":"markdown","metadata":{},"source":"# You Try It"}
{"cell_type":"markdown","metadata":{},"source":"Selecting data from numpy arrays like this is the key to Homeworks 1 and 2. Try the following exercises, and see how you fare with the homeworks again."}
{"cell_type":"markdown","metadata":{},"source":"1. The first column in the file (column 0) is the year. Plot the temperature vs the year.\n2. Calculate the average temperature for years before and after 1900.\n3. You don't need to create the mask on a seperate line and save it in a variable. Try and make a 1D array of only those months where the temp is greater than ten degrees, in a single line of Python."}